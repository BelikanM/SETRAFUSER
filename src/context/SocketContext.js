import React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';
import { io } from 'socket.io-client';
import { UserContext } from './UserContext';

// Configuration Socket.io optimis√©e
const SOCKET_URL = process.env.REACT_APP_SOCKET_URL || 'http://localhost:5000';

const SOCKET_OPTIONS = {
  transports: ['websocket', 'polling'],
  upgrade: true,
  rememberUpgrade: true,
  timeout: 20000,
  forceNew: false,
  reconnection: true,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
  maxReconnectionAttempts: 5,
  randomizationFactor: 0.5,
  autoConnect: false,
  withCredentials: true
};

// Cr√©ation du contexte
export const SocketContext = createContext({
  socket: null,
  isConnected: false,
  connectionStatus: 'disconnected',
  onlineUsers: new Set(),
  lastActivity: null,
  connect: () => {},
  disconnect: () => {},
  emit: () => {},
  on: () => {},
  off: () => {},
  reconnect: () => {}
});

// Provider principal
export const SocketProvider = ({ children }) => {
  const { user, token } = useContext(UserContext);
  
  // √âtats du socket
  const [socket, setSocket] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  const [onlineUsers, setOnlineUsers] = useState(new Set());
  const [lastActivity, setLastActivity] = useState(null);
  
  // Refs pour √©viter les re-renders
  const socketRef = useRef(null);
  const reconnectTimeoutRef = useRef(null);
  const heartbeatIntervalRef = useRef(null);
  const connectionAttemptsRef = useRef(0);
  const isConnectingRef = useRef(false);
  const isUnmountedRef = useRef(false);

  // Fonction de connexion optimis√©e
  const connect = useCallback(() => {
    if (!user || !token || isConnectingRef.current || socketRef.current?.connected || isUnmountedRef.current) {
      return;
    }

    console.log('üîå Initialisation connexion Socket.io...', { userId: user._id });
    isConnectingRef.current = true;
    setConnectionStatus('connecting');

    try {
      // Cr√©ation de la nouvelle instance socket
      const newSocket = io(SOCKET_URL, {
        ...SOCKET_OPTIONS,
        auth: {
          token,
          userId: user._id,
          userRole: user.role,
          userName: `${user.firstName} ${user.lastName}`,
          userEmail: user.email
        },
        query: {
          userId: user._id,
          role: user.role
        }
      });

      // √âv√©nements de connexion avec protection contre les fuites m√©moire
      newSocket.on('connect', () => {
        if (isUnmountedRef.current) return;
        
        console.log('‚úÖ Socket connect√©:', newSocket.id);
        setIsConnected(true);
        setConnectionStatus('connected');
        setLastActivity(new Date());
        connectionAttemptsRef.current = 0;
        isConnectingRef.current = false;

        // Rejoindre les salles appropri√©es
        newSocket.emit('join-user-room', { 
          userId: user._id, 
          role: user.role,
          userInfo: {
            firstName: user.firstName,
            lastName: user.lastName,
            email: user.email
          }
        });

        // D√©marrer le heartbeat
        startHeartbeat(newSocket);
      });

      newSocket.on('disconnect', (reason) => {
        if (isUnmountedRef.current) return;
        
        console.log('üîå Socket d√©connect√©:', reason);
        setIsConnected(false);
        setConnectionStatus('disconnected');
        isConnectingRef.current = false;
        stopHeartbeat();

        // Reconnexion automatique selon la raison
        if (reason === 'io server disconnect') {
          console.log('‚ùå Connexion ferm√©e par le serveur');
        } else if (reason === 'transport close' || reason === 'transport error') {
          scheduleReconnect();
        }
      });

      newSocket.on('connect_error', (error) => {
        if (isUnmountedRef.current) return;
        
        console.error('‚ùå Erreur connexion Socket:', error);
        setConnectionStatus('error');
        isConnectingRef.current = false;
        connectionAttemptsRef.current++;

        if (connectionAttemptsRef.current < SOCKET_OPTIONS.maxReconnectionAttempts) {
          scheduleReconnect();
        } else {
          console.error('‚ùå Nombre maximum de tentatives de reconnexion atteint');
          setConnectionStatus('failed');
        }
      });

      // √âv√©nements utilisateurs en ligne avec protection
      newSocket.on('users-online-update', (users) => {
        if (isUnmountedRef.current) return;
        
        console.log('üë• Mise √† jour utilisateurs en ligne:', users.length);
        setOnlineUsers(new Set(users.map(u => u.userId || u._id)));
      });

      newSocket.on('user-connected', (userData) => {
        if (isUnmountedRef.current) return;
        
        console.log('üë§ Utilisateur connect√©:', userData);
        setOnlineUsers(prev => new Set([...prev, userData.userId]));
      });

      newSocket.on('user-disconnected', (userData) => {
        if (isUnmountedRef.current) return;
        
        console.log('üë§ Utilisateur d√©connect√©:', userData);
        setOnlineUsers(prev => {
          const newSet = new Set(prev);
          newSet.delete(userData.userId);
          return newSet;
        });
      });

      // √âv√©nements GPS et localisation avec protection
      newSocket.on('location-update', (locationData) => {
        if (isUnmountedRef.current) return;
        
        console.log('üìç Mise √† jour position:', locationData);
        setLastActivity(new Date());
      });

      // √âv√©nements labels de carte avec protection
      newSocket.on('new-map-label', (labelData) => {
        if (isUnmountedRef.current) return;
        
        console.log('üè∑Ô∏è Nouveau label ajout√©:', labelData);
      });

      newSocket.on('update-map-label', (labelData) => {
        if (isUnmountedRef.current) return;
        
        console.log('üè∑Ô∏è Label mis √† jour:', labelData);
      });

      newSocket.on('delete-map-label', (data) => {
        if (isUnmountedRef.current) return;
        
        console.log('üè∑Ô∏è Label supprim√©:', data);
      });

      // √âv√©nements de notification avec protection
      newSocket.on('notification', (notificationData) => {
        if (isUnmountedRef.current) return;
        
        console.log('üîî Notification re√ßue:', notificationData);
      });

      // √âv√©nements d'erreur avec protection
      newSocket.on('error', (error) => {
        if (isUnmountedRef.current) return;
        
        console.error('‚ùå Erreur Socket:', error);
      });

      // √âv√©nement heartbeat avec protection
      newSocket.on('pong', () => {
        if (isUnmountedRef.current) return;
        
        setLastActivity(new Date());
      });

      // Sauvegarder la r√©f√©rence
      socketRef.current = newSocket;
      setSocket(newSocket);

      // Connexion manuelle si autoConnect est false
      newSocket.connect();

    } catch (error) {
      console.error('‚ùå Erreur lors de la cr√©ation du socket:', error);
      setConnectionStatus('error');
      isConnectingRef.current = false;
    }
  }, [user, token]);

  // Fonction de d√©connexion optimis√©e
  const disconnect = useCallback(() => {
    console.log('üîå D√©connexion Socket...');
    
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }

    stopHeartbeat();

    if (socketRef.current) {
      socketRef.current.removeAllListeners();
      socketRef.current.disconnect();
      socketRef.current = null;
    }

    setSocket(null);
    setIsConnected(false);
    setConnectionStatus('disconnected');
    setOnlineUsers(new Set());
    isConnectingRef.current = false;
    connectionAttemptsRef.current = 0;
  }, []);

  // Fonction de reconnexion optimis√©e
  const reconnect = useCallback(() => {
    console.log('üîÑ Reconnexion Socket...');
    disconnect();
    setTimeout(() => {
      if (!isUnmountedRef.current) {
        connect();
      }
    }, 1000);
  }, [disconnect, connect]);

  // Planifier une reconnexion avec protection
  const scheduleReconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }

    const delay = Math.min(
      SOCKET_OPTIONS.reconnectionDelay * Math.pow(2, connectionAttemptsRef.current),
      SOCKET_OPTIONS.reconnectionDelayMax
    );

    console.log(`üîÑ Reconnexion programm√©e dans ${delay}ms...`);
    setConnectionStatus('reconnecting');

    reconnectTimeoutRef.current = setTimeout(() => {
      if (!isUnmountedRef.current && connectionAttemptsRef.current < SOCKET_OPTIONS.maxReconnectionAttempts) {
        connect();
      }
    }, delay);
  }, [connect]);

  // Heartbeat pour maintenir la connexion avec protection
  const startHeartbeat = useCallback((socket) => {
    stopHeartbeat();
    
    heartbeatIntervalRef.current = setInterval(() => {
      if (!isUnmountedRef.current && socket && socket.connected) {
        socket.emit('ping');
      }
    }, 30000);
  }, []);

  const stopHeartbeat = useCallback(() => {
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
      heartbeatIntervalRef.current = null;
    }
  }, []);

  // Fonctions helper pour √©mettre et √©couter avec protection
  const emit = useCallback((event, data) => {
    if (socketRef.current && socketRef.current.connected && !isUnmountedRef.current) {
      socketRef.current.emit(event, data);
      setLastActivity(new Date());
    } else {
      console.warn('‚ö†Ô∏è Tentative d\'√©mission sur socket d√©connect√©:', event);
    }
  }, []);

  const on = useCallback((event, callback) => {
    if (socketRef.current && !isUnmountedRef.current) {
      const protectedCallback = (...args) => {
        if (!isUnmountedRef.current) {
          callback(...args);
        }
      };
      socketRef.current.on(event, protectedCallback);
      return () => {
        if (socketRef.current) {
          socketRef.current.off(event, protectedCallback);
        }
      };
    }
  }, []);

  const off = useCallback((event, callback) => {
    if (socketRef.current) {
      if (callback) {
        socketRef.current.off(event, callback);
      } else {
        socketRef.current.off(event);
      }
    }
  }, []);

  // Effet pour g√©rer la connexion/d√©connexion avec protection
  useEffect(() => {
    isUnmountedRef.current = false;
    
    if (user && token) {
      connect();
    } else {
      disconnect();
    }

    return () => {
      isUnmountedRef.current = true;
      disconnect();
    };
  }, [user, token, connect, disconnect]);

  // Cleanup au d√©montage avec protection compl√®te
  useEffect(() => {
    return () => {
      isUnmountedRef.current = true;
      
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      stopHeartbeat();
      disconnect();
    };
  }, [disconnect, stopHeartbeat]);

  // Gestion de la visibilit√© de la page avec protection
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (isUnmountedRef.current) return;
      
      if (document.hidden) {
        console.log('üì± Page masqu√©e - maintien connexion Socket');
      } else {
        console.log('üì± Page visible - v√©rification connexion Socket');
        if (!isConnected && user && token) {
          setTimeout(() => {
            if (!isUnmountedRef.current) {
              connect();
            }
          }, 500);
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [isConnected, user, token, connect]);

  // Gestion des √©v√©nements r√©seau avec protection
  useEffect(() => {
    const handleOnline = () => {
      if (isUnmountedRef.current) return;
      
      console.log('üåê Connexion r√©seau r√©tablie');
      if (!isConnected && user && token) {
        setTimeout(() => {
          if (!isUnmountedRef.current) {
            connect();
          }
        }, 1000);
      }
    };

    const handleOffline = () => {
      if (isUnmountedRef.current) return;
      
      console.log('üåê Connexion r√©seau perdue');
      setConnectionStatus('offline');
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [isConnected, user, token, connect]);

  // Valeur du contexte
  const contextValue = {
    socket: socketRef.current,
    isConnected,
    connectionStatus,
    onlineUsers,
    lastActivity,
    connect,
    disconnect,
    reconnect,
    emit,
    on,
    off
  };

  return (
    <SocketContext.Provider value={contextValue}>
      {children}
    </SocketContext.Provider>
  );
};

// Hook personnalis√© pour utiliser le contexte
export const useSocket = () => {
  const context = useContext(SocketContext);
  
  if (!context) {
    throw new Error('useSocket doit √™tre utilis√© dans un SocketProvider');
  }
  
  return context;
};

// Hook pour les √©v√©nements socket avec cleanup automatique am√©lior√©
export const useSocketEvent = (event, callback, dependencies = []) => {
  const { socket, on, off } = useSocket();
  const callbackRef = useRef(callback);
  const cleanupRef = useRef(null);

  // Mettre √† jour la r√©f√©rence du callback
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  useEffect(() => {
    if (socket && callbackRef.current) {
      const protectedCallback = (...args) => {
        if (callbackRef.current) {
          callbackRef.current(...args);
        }
      };
      
      cleanupRef.current = on(event, protectedCallback);
      
      return () => {
        if (cleanupRef.current) {
          cleanupRef.current();
        }
      };
    }
  }, [socket, event, on, ...dependencies]);

  // Cleanup au d√©montage
  useEffect(() => {
    return () => {
      if (cleanupRef.current) {
        cleanupRef.current();
      }
    };
  }, []);
};

// Hook pour √©mettre des √©v√©nements avec debounce am√©lior√©
export const useSocketEmit = (delay = 300) => {
  const { emit, isConnected } = useSocket();
  const timeoutRef = useRef(null);
  const queueRef = useRef([]);

  const debouncedEmit = useCallback((event, data) => {
    if (!isConnected) {
      console.warn('‚ö†Ô∏è Socket d√©connect√©, √©mission ignor√©e:', event);
      return;
    }

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // Ajouter √† la queue
    queueRef.current.push({ event, data });

    timeoutRef.current = setTimeout(() => {
      // Traiter la queue
      const queue = [...queueRef.current];
      queueRef.current = [];
      
      queue.forEach(({ event, data }) => {
        emit(event, data);
      });
    }, delay);
  }, [emit, delay, isConnected]);

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      queueRef.current = [];
    };
  }, []);

  return debouncedEmit;
};

// Hook pour surveiller le statut de connexion
export const useConnectionStatus = () => {
  const { connectionStatus, isConnected, lastActivity } = useSocket();
  
  return {
    status: connectionStatus,
    isConnected,
    lastActivity,
    isOnline: connectionStatus === 'connected',
    isConnecting: connectionStatus === 'connecting',
    isReconnecting: connectionStatus === 'reconnecting',
    isOffline: connectionStatus === 'offline',
    hasError: connectionStatus === 'error' || connectionStatus === 'failed'
  };
};

// Composant indicateur de statut de connexion optimis√©
export const SocketStatusIndicator = ({ style = {} }) => {
  const { status, isConnected } = useConnectionStatus();

  const getStatusInfo = () => {
    switch (status) {
      case 'connected':
        return { color: '#10b981', icon: 'üü¢', text: 'Connect√©' };
      case 'connecting':
        return { color: '#f59e0b', icon: 'üü°', text: 'Connexion...' };
      case 'reconnecting':
        return { color: '#f59e0b', icon: 'üîÑ', text: 'Reconnexion...' };
      case 'offline':
        return { color: '#6b7280', icon: '‚ö´', text: 'Hors ligne' };
      case 'error':
        return { color: '#ef4444', icon: 'üî¥', text: 'Erreur' };
      case 'failed':
        return { color: '#dc2626', icon: '‚ùå', text: '√âchec' };
      default:
        return { color: '#6b7280', icon: '‚ö´', text: 'D√©connect√©' };
    }
  };

  const statusInfo = getStatusInfo();

  return (
    <div style={{
      display: 'flex',
      alignItems: 'center',
      gap: '6px',
      padding: '4px 8px',
      borderRadius: '12px',
      fontSize: '12px',
      fontWeight: '500',
      color: statusInfo.color,
      backgroundColor: `${statusInfo.color}15`,
      border: `1px solid ${statusInfo.color}30`,
      transition: 'all 0.3s ease',
      ...style
    }}>
      <span>{statusInfo.icon}</span>
      <span>{statusInfo.text}</span>
    </div>
  );
};

export default SocketProvider;

